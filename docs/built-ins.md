functions:
- @print(string)
- @println(string)
- @import(string)
- @typeOf(type)
- @this()

primatives:
- uint
- u# # arbitray size unsigned integer
- int
- i# # arbitray size signed integer
- float
- f# # arbitrary size float
- string
- bool
- unit or ()
- type (form or kind)
- pointer
    - annotation: type*
    - instance: variable.*
- reference
    - annotation: type&
    - instance: variable.&
- array
    - annotation: \[size]type
    - instance: \[size]{val, ...}
- dynamic array
    - annotation: \[|size|]type
    - instance: \[|size|]{val, val, ...}
- static map
    - annotation: \[key, value]
    - instance: \[key, value]{key = val, ...}
- tuple
    - annotation: tuple {type, type, ...}
    - instance: {val, val, ...}
- result
    - annotation: type?
    - unwrap: variable.?
    - sugar for variant {ok: type, error: atom}
- option
    - annotation: type!
    - unwrap: variable.!
    - sugar for variant {some: type, none}
- function
    - annotation: (parameters) -> return
    - instance: (parameters, |optional captures|) do // |..| to capture all
      code
    end
    - one-liner: (parameters) => |optional captures| code
- module
    - annotation: module {name: type, name: type, ...} // Requires passed in module to have consts with matching name: type, can have any local bindings
    - instance: module {const name = , local name = , ...}
- record
    - annotation: record {field: type, field: type, ...}
    - instance: {field: val, field: val, ...}
- variant (tagged union)
    - annotation: variant {name: type, name: type, ...}
    - instance: variant.kind(val)
- atom
    - annotation: atom
    - instance: 'identifier
        - 'a
        - 'fast
